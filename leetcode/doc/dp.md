## 背包问题
#### 0 1背包
v表示体积，w表示价值，每件物品只有一件
在背包能装得下的情况下，找出总价值最大

dp问题一般从**状态表示**与**状态计算**两个方面思考, 思考每个状态下表示的真正含义是什么，如何从前面的状态递推到当前状态

* 状态表示f(i,j)
	* 集合(每个状态表示的其实是一个集合)
		* 具体含义
		* 条件
	* 属性(表示集合的某种属性, 一般是集合中的最大值，最小值，数量 )
* 状态计算(集合的划分)


0,1背包问题中，集合表示所有满足条件的选法集合，满足两个条件: 1. 只从前i个物品中选 2. 选中物品总体积 <= j
集合划分: 划分成2个子集, 1. 不包含i -> f(i-1,j)  2. 包含i -> f(i - 1, j - v(i)) + w(i)

```
  // w 表示每件物品价值 1 to n，你件物品，背包体积v
  // f(i)(j) = f(i - 1)(j) + f(i - 1)(j - v(i)) + w(i)； 不选i与选i
  private def zeroOneBag(w: Array[Int], v: Array[Int],  n: Int, V: Int): Int = {
    val f: Array[Array[Int]] = Array.ofDim(n + 1, V + 1)
    // f(0)(x) = 0，不限则物品，最后价值为0
    for (i <- 1 to n; j <- 0 to V) {
      f(i)(j) = f(i - 1)(j)
      if (j >= v(i)) f(i)(j) = Math.max(f(i)(j), f(i - 1)(j - v(i)) + w(i))
    }
    f(n)(V)
  }
```

#### 完全背包
每类物品有无限个

* 状态表示f(i,j)
  * 集合: 所有只考虑前i个物体，且总体积不大于j的所有选法
  * 属性: 所有选法的总价值最大值
* 状态计算(集合的划分) 
  * 按第i个物品选多少个来划分[0,k]个子集
  * f(i - 1, j - k*v(i)) + k*w(i)  k in[0, x]
综合起来 f(i,j) = f(i - 1, j - v(i)*k) + k*w(i); 时间复杂度m*n*k
TODO 二维优化...

#### 多重背包
每个物品的个数不一样
类似于完全背包，k有具体上限
TODO logn优化...

#### 分组背包
物品有n组，每组内有若干个物品；每组内只能选一个物品
* 状态表示f(i,j)
  * 集合:表示只从前i组物品中选，且总体积不大于j的所有选法
  * 属性: 最大价值
* 状态计算(集合的划分)
  * 枚举第i组物品选哪个(不选，到选第n个), f(i,j) = f(i - 1, j - v(i,k)) + w(i,k)


## 线性DP

递推方程有明显线性关系(1维，2维，3维), 多维状态。如二维dp中，状态需要一行一行的求

#### 数字三角形
    7
   3 8
  8 1 0
 2 7 4 4
4 5 2 6 5
从左上方一直走到最下层，使路径上的数字和最大
* 状态表示 f(i,j)
  * 集合：表示f(0,0)到该点的路径和
  * 路径和最大值
* 状态计算: 状态集合分为两类: 从左上方来f(i - 1, j - 1)，或从右上方来 f(i - 1, j); f(i, j) = max(f(i - 1, j), f(i - 1, j - 1)) + v

#### 最长上升子序列


## 区间DP

## 计数类DP

## 数位统计DP

## 状态压缩DP

## 树形DP

## 记忆化搜索