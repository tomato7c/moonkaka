## 背包问题
#### 0 1背包
v表示体积，w表示价值，每件物品只有一件
在背包能装得下的情况下，找出总价值最大

dp问题一般从**状态表示**与**状态计算**两个方面思考, 思考每个状态下表示的真正含义是什么，如何从前面的状态递推到当前状态

* 状态表示f(i,j)
	* 集合(每个状态表示的其实是一个集合)
		* 具体含义
		* 条件
	* 属性(表示集合的某种属性, 一般是集合中的最大值，最小值，数量 )
* 状态计算(集合的划分)


0,1背包问题中，集合表示所有满足条件的选法集合，满足两个条件: 1. 只从前i个物品中选 2. 选中物品总体积 <= j
集合划分: 划分成2个子集, 1. 不包含i -> f(i-1,j)  2. 包含i -> f(i - 1, j - v(i)) + w(i)

```
  // w 表示每件物品价值 1 to n，你件物品，背包体积v
  // f(i)(j) = f(i - 1)(j) + f(i - 1)(j - v(i)) + w(i)； 不选i与选i
  private def zeroOneBack(w: Array[Int], v: Array[Int],  n: Int, V: Int): Int = {
    val f: Array[Array[Int]] = Array.ofDim(n + 1, V + 1)
    // f(0)(x) = 0，不限则物品，最后价值为0
    for (i <- 1 to n; j <- 0 to V) {
      f(i)(j) = f(i - 1)(j)
      if (j >= v(i)) f(i)(j) = Math.max(f(i)(j), f(i - 1)(j - v(i)) + w(i))
    }
    f(n)(V)
  }
```


#### 完全背包
每类物品有无限个

#### 多重背包
每个物品的个数不一样

#### 分组背包
物品有n组，每组内有若干个物品；每组内只能选一个物品

## 线性DP

## 区间DP

## 计数类DP

## 数位统计DP

## 状态压缩DP

## 树形DP

## 记忆化搜索